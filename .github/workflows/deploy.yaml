name: Deploy to VPS

on:
  push:
    branches: [main]
  schedule:
    - cron: "0 * * * *"
  workflow_dispatch:

permissions:
  contents: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Sync main with upstream and push to origin
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          if ! git remote get-url upstream >/dev/null 2>&1; then
            echo "Adding upstream remote..."
            git remote add upstream https://github.com/enfyra/server.git
          fi

          echo "Fetching origin and upstream..."
          git fetch origin main --force
          git fetch upstream main --force || {
            echo "‚ö†Ô∏è Failed to fetch upstream. Continuing with origin only..."
          }

          echo "Checking out main and resetting to origin/main..."
          git checkout main
          git reset --hard origin/main

          if git rev-parse --quiet upstream/main >/dev/null; then
            COMMITS_BEHIND=$(git rev-list --count HEAD..upstream/main 2>/dev/null || echo "0")
            echo "Commits behind upstream/main: $COMMITS_BEHIND"

            if [ "$COMMITS_BEHIND" != "0" ]; then
              echo "üîÑ Merging upstream/main into main..."
              git merge upstream/main --no-edit --no-ff || {
                echo "‚ö†Ô∏è Merge conflict detected. Retrying with 'theirs' strategy..."
                git merge --abort 2>/dev/null || true
                git merge upstream/main --no-edit -X theirs || {
                  echo "‚ùå Failed to merge upstream/main. Keeping origin/main state."
                }
              }
            else
              echo "‚úÖ main is already up to date with upstream/main."
            fi
          else
            echo "‚ÑπÔ∏è upstream/main not available. Skipping upstream merge."
          fi

          if ! git diff --quiet origin/main..HEAD; then
            echo "Pushing updated main to origin..."
            git push origin main --force-with-lease
          else
            echo "‚úÖ No changes to push to origin/main."
          fi

      - name: Install sshpass
        run: |
          sudo apt-get update
          sudo apt-get install -y sshpass

      - name: Deploy to VPS via sshpass
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_PASSWORD: ${{ secrets.VPS_PASSWORD }}
        run: |
          EVENT_NAME="${{ github.event_name }}"
          sshpass -p "$VPS_PASSWORD" ssh -o StrictHostKeyChecking=no $VPS_USER@$VPS_HOST "bash -s \"$EVENT_NAME\"" <<'ENDSSH'
            # Set project variables
            export PROJECT_NAME="landing-server"
            export APP_DIR="/apps/landing-server"
            export EVENT_NAME="$1"
            export PATH="$PATH:/usr/bin:/usr/local/bin:$HOME/.local/bin"

            # Find tool paths
            GIT_PATH=$(which git || echo "/usr/bin/git")
            NPM_PATH=$(which npm || echo "/usr/bin/npm")
            YARN_PATH=$(which yarn || echo "")
            PM2_PATH=$(which pm2 || echo "$HOME/.local/bin/pm2")

            # Install yarn if not found
            if [ -z "$YARN_PATH" ]; then
              echo "Yarn not found, installing..."
              $NPM_PATH install -g yarn
              YARN_PATH=$(which yarn || echo "$HOME/.local/bin/yarn")
            fi

            echo "=== Deploy triggered by $EVENT_NAME ==="

            echo "Tools found:"
            echo "Git: $GIT_PATH"
            echo "NPM: $NPM_PATH"
            echo "Yarn: $YARN_PATH"
            echo "PM2: $PM2_PATH"

            # Navigate to app directory
            cd $APP_DIR
            echo "Current directory: $(pwd)"

            # Ensure we're on main branch
            $GIT_PATH checkout main 2>/dev/null || true

            # Capture current commit before fetch
            CURRENT_COMMIT=$($GIT_PATH rev-parse HEAD 2>/dev/null || echo "none")
            echo "Current local commit: $CURRENT_COMMIT"

            # Fetch latest from origin and decide whether to deploy
            if $GIT_PATH fetch origin main --force 2>&1; then
              ORIGIN_COMMIT=$($GIT_PATH rev-parse origin/main 2>/dev/null || echo "none")
              echo "Remote commit (origin/main): $ORIGIN_COMMIT"

              if [ "$CURRENT_COMMIT" != "none" ] && [ "$ORIGIN_COMMIT" != "none" ] && [ "$CURRENT_COMMIT" = "$ORIGIN_COMMIT" ]; then
                echo "‚úÖ No new commits on origin/main. Skipping redeploy."
                exit 0
              fi

              echo "Updating working tree to origin/main..."
              $GIT_PATH reset --hard origin/main
              $GIT_PATH clean -fd
              echo "‚úÖ Code updated to latest from origin/main"
            else
              echo "‚ö†Ô∏è Failed to fetch from origin. Continuing with existing code..."
            fi

            FINAL_COMMIT=$($GIT_PATH rev-parse HEAD 2>/dev/null || echo "unknown")
            echo "‚úÖ Deploying commit: $FINAL_COMMIT"

            # Install dependencies with yarn
            echo "Installing dependencies with yarn..."
            $YARN_PATH install --frozen-lockfile

            # Setup environment file
            echo "Setting up environment..."
            if [ ! -f .env ]; then
              echo "‚ö†Ô∏è  .env file not found! Creating from template..."
              cp env_example .env || echo "env_example not found, manual .env setup required"
            fi

            # Ensure ecosystem.config.js exists
            echo "Setting up PM2 ecosystem config..."
            if [ ! -f ecosystem.config.js ]; then
              echo "‚ö†Ô∏è  ecosystem.config.js not found! Creating default config..."
              printf 'module.exports = {\n  apps: [\n    {\n      name: "landing-server",\n      script: "./dist/src/main.js",\n      exec_mode: "fork",\n      env: {\n        NODE_ENV: "production",\n      },\n      error_file: "./logs/pm2-error.log",\n      out_file: "./logs/pm2-out.log",\n      log_date_format: "YYYY-MM-DD HH:mm:ss Z",\n      merge_logs: true,\n      autorestart: true,\n      max_memory_restart: "1G",\n      watch: false,\n      ignore_watch: ["node_modules", "logs", ".git"],\n    },\n  ],\n};' > ecosystem.config.js
              echo "‚úÖ Created ecosystem.config.js"
            else
              echo "‚úÖ ecosystem.config.js already exists"
            fi

            # Build application
            echo "Building application..."
            $YARN_PATH build

            # Stop PM2 application completely to avoid conflicts
            echo "Stopping PM2 application..."
            $PM2_PATH stop $PROJECT_NAME || true
            $PM2_PATH delete $PROJECT_NAME || true

            # Clean start PM2 application
            echo "Starting PM2 application clean..."
            $PM2_PATH start ecosystem.config.js

            # Wait for app to initialize
            echo "Waiting for app to initialize..."
            sleep 10

            # Show PM2 status
            $PM2_PATH status

            # Health check
            echo "=== Health Check ==="
            sleep 5
            if $PM2_PATH show $PROJECT_NAME | grep -q "online"; then
              echo "‚úÖ Application is running successfully"
            else
              echo "‚ùå Application failed to start"
              $PM2_PATH logs $PROJECT_NAME --lines 20 --nostream
              exit 1
            fi

            # Show logs without tailing (just print and exit)
            echo "=== Recent logs ==="
            $PM2_PATH logs $PROJECT_NAME --lines 30 --nostream || {
              echo "Using alternative log method..."
              timeout 3s $PM2_PATH logs $PROJECT_NAME --lines 30 || true
            }

            echo "=== PM2 Deployment completed successfully ==="
          ENDSSH
